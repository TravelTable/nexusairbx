// src/lib/exportToRoblox.js
// Generate a Roblox LocalScript that builds the UI and wires interactions/monetization.

function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}

function parseColor(input) {
  const s = String(input || "").trim();
  if (!s || s === "transparent") {
    return { color3: "Color3.fromRGB(255,255,255)", transparency: 1 };
  }

  const rgba = s.match(/^rgba?\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*(?:,\s*([0-9.]+)\s*)?\)$/i);
  if (rgba) {
    const r = clamp(Number(rgba[1]) || 0, 0, 255);
    const g = clamp(Number(rgba[2]) || 0, 0, 255);
    const b = clamp(Number(rgba[3]) || 0, 0, 255);
    const a = rgba[4] === undefined ? 1 : clamp(Number(rgba[4]) || 1, 0, 1);
    return {
      color3: `Color3.fromRGB(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`,
      transparency: clamp(1 - a, 0, 1),
    };
  }

  const hex = s.match(/^#([0-9a-f]{6})$/i);
  if (hex) {
    const v = hex[1];
    const r = parseInt(v.slice(0, 2), 16);
    const g = parseInt(v.slice(2, 4), 16);
    const b = parseInt(v.slice(4, 6), 16);
    return { color3: `Color3.fromRGB(${r}, ${g}, ${b})`, transparency: 0 };
  }

  return { color3: "Color3.fromRGB(255,255,255)", transparency: 0 };
}

function safeName(s) {
  const t = String(s || "Item");
  const cleaned = t.replace(/[^a-zA-Z0-9_]/g, "_").slice(0, 64);
  return cleaned || "Item";
}

function shouldExport(it) {
  if (it && typeof it === "object") {
    if (it.export === false) return false;
    const role = String(it.role || "").toLowerCase();
    if (role === "layout" || role === "background") return false;
  }
  return true;
}

function toNum(x, fallback) {
  const n = Number(x);
  return Number.isFinite(n) ? n : fallback;
}

export function exportToRoblox({ canvasSize, items }) {
  const w = toNum(canvasSize?.w, 1280);
  const h = toNum(canvasSize?.h, 720);

  const srcItems = Array.isArray(items) ? items.filter(shouldExport) : [];
  const byId = new Map(srcItems.map((it) => [String(it.id), it]));

  function parentVar(it) {
    const pid = it.parentId ? String(it.parentId) : "";
    if (pid && byId.has(pid)) return `nodes["${pid}"]`;
    return "gui";
  }

  const ordered = [...srcItems].sort((a, b) => toNum(a.zIndex, 1) - toNum(b.zIndex, 1));

  const lines = [];
  lines.push(`-- Generated by Nexus UI Builder`);
  lines.push(`-- Place this as a LocalScript in StarterPlayerScripts OR StarterGui`);
  lines.push(``);
  lines.push(`local Players = game:GetService("Players")`);
  lines.push(`local TweenService = game:GetService("TweenService")`);
  lines.push(`local MarketplaceService = game:GetService("MarketplaceService")`);
  lines.push(``);
  lines.push(`local player = Players.LocalPlayer`);
  lines.push(`local playerGui = player:WaitForChild("PlayerGui")`);
  lines.push(``);
  lines.push(`local existing = playerGui:FindFirstChild("GeneratedUI")`);
  lines.push(`if existing then existing:Destroy() end`);
  lines.push(``);
  lines.push(`local gui = Instance.new("ScreenGui")`);
  lines.push(`gui.Name = "GeneratedUI"`);
  lines.push(`gui.ResetOnSpawn = false`);
  lines.push(`gui.IgnoreGuiInset = true`);
  lines.push(`gui.Parent = playerGui`);
  lines.push(``);
  lines.push(`local nodes = {}`);
  lines.push(``);
  lines.push(`local function addCorner(inst, px)`);
  lines.push(`  if not px or px <= 0 then return end`);
  lines.push(`  local c = Instance.new("UICorner")`);
  lines.push(`  c.CornerRadius = UDim.new(0, px)`);
  lines.push(`  c.Parent = inst`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`local function addStroke(inst, color3Expr, thickness, transparency)`);
  lines.push(`  local s = Instance.new("UIStroke")`);
  lines.push(`  s.Color = ${"Color3.fromRGB(255,255,255)"}`);
  lines.push(`  if color3Expr then`);
  lines.push(`    s.Color = color3Expr`);
  lines.push(`  end`);
  lines.push(`  s.Thickness = thickness or 1`);
  lines.push(`  s.Transparency = transparency or 0`);
  lines.push(`  s.Parent = inst`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`local function ensureScale(inst)`);
  lines.push(`  local sc = inst:FindFirstChildOfClass("UIScale")`);
  lines.push(`  if not sc then`);
  lines.push(`    sc = Instance.new("UIScale")`);
  lines.push(`    sc.Scale = 1`);
  lines.push(`    sc.Parent = inst`);
  lines.push(`  end`);
  lines.push(`  return sc`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`local function attachButtonFX(btn)`);
  lines.push(`  local scale = ensureScale(btn)`);
  lines.push(`  local hoverIn = TweenService:Create(scale, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.03})`);
  lines.push(`  local hoverOut = TweenService:Create(scale, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.00})`);
  lines.push(`  local pressIn = TweenService:Create(scale, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 0.96})`);
  lines.push(`  local pressOut = TweenService:Create(scale, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Scale = 1.00})`);
  lines.push(``);
  lines.push(`  btn.MouseEnter:Connect(function() hoverIn:Play() end)`);
  lines.push(`  btn.MouseLeave:Connect(function() hoverOut:Play() end)`);
  lines.push(`  btn.Activated:Connect(function()`);
  lines.push(`    pressIn:Play()`);
  lines.push(`    task.delay(0.11, function() pressOut:Play() end)`);
  lines.push(`  end)`);
  lines.push(`end`);
  lines.push(``);
  lines.push(`local function applyRule(rule)`);
  lines.push(`  if type(rule) ~= "table" then return end`);
  lines.push(`  local t = rule.type`);
  lines.push(`  local targetId = rule.targetId`);
  lines.push(`  if not targetId or not nodes[targetId] then return end`);
  lines.push(`  local node = nodes[targetId]`);
  lines.push(`  if t == "ToggleVisible" then`);
  lines.push(`    node.Visible = not node.Visible`);
  lines.push(`  elseif t == "SetVisible" then`);
  lines.push(`    node.Visible = (rule.value == nil) and true or (rule.value == true)`);
  lines.push(`  elseif t == "SetHidden" then`);
  lines.push(`    node.Visible = false`);
  lines.push(`  end`);
  lines.push(`end`);
  lines.push(``);

  for (const it of ordered) {
    const id = String(it.id);
    const type = String(it.type || "Frame");

    let cls = "Frame";
    if (type === "TextLabel") cls = "TextLabel";
    else if (type === "TextButton" || type === "MonetizationButton") cls = "TextButton";
    else if (type === "ImageLabel") cls = "ImageLabel";
    else if (type === "Group" || type === "Spacer") cls = "Frame";
    else if (type === "Rectangle" || type === "Circle" || type === "Line") cls = "Frame";

    const name = safeName(it.name || type || id);

    const x = Math.round(toNum(it.x, 0));
    const y = Math.round(toNum(it.y, 0));
    const iw = Math.round(toNum(it.w, 100));
    const ih = Math.round(toNum(it.h, 50));
    const z = Math.round(toNum(it.zIndex, 1));
    const visible = (it.visible === false) ? "false" : "true";

    const fill = parseColor(it.fill);
    const opacity = it.opacity === undefined ? 1 : clamp(toNum(it.opacity, 1), 0, 1);
    const bgTrans = clamp(fill.transparency + (1 - opacity), 0, 1);

    const radius = clamp(toNum(it.radius, 12), 0, 200);

    const strokeEnabled = !!it.stroke;
    const strokeColor = parseColor(it.strokeColor || "rgba(148,163,184,0.22)");
    const strokeWidth = clamp(toNum(it.strokeWidth, 2), 0, 20);

    lines.push(`do`);
    lines.push(`  local node = Instance.new("${cls}")`);
    lines.push(`  node.Name = "${name}"`);
    lines.push(`  node.Size = UDim2.fromOffset(${iw}, ${ih})`);
    lines.push(`  node.Position = UDim2.fromOffset(${x}, ${y})`);
    lines.push(`  node.ZIndex = ${z}`);
    lines.push(`  node.Visible = ${visible}`);
    lines.push(`  node.Parent = ${parentVar(it)}`);
    lines.push(`  nodes["${id}"] = node`);
    lines.push(``);

    if (cls === "Frame" || cls === "TextButton" || cls === "ImageLabel" || cls === "TextLabel") {
      if (type === "Spacer" || type === "Group") {
        lines.push(`  node.BackgroundTransparency = 1`);
      } else {
        lines.push(`  node.BackgroundColor3 = ${fill.color3}`);
        lines.push(`  node.BackgroundTransparency = ${bgTrans.toFixed(3)}`);
      }
    }

    if (type === "Circle") {
      lines.push(`  addCorner(node, math.floor(math.min(${iw}, ${ih})/2))`);
    } else {
      if (radius > 0 && (cls === "Frame" || cls === "TextButton" || cls === "ImageLabel")) {
        lines.push(`  addCorner(node, ${Math.round(radius)})`);
      }
    }

    if (strokeEnabled && strokeWidth > 0 && (cls === "Frame" || cls === "TextButton" || cls === "ImageLabel")) {
      lines.push(`  addStroke(node, ${strokeColor.color3}, ${strokeWidth}, ${strokeColor.transparency.toFixed(3)})`);
    }

    if (cls === "TextLabel" || cls === "TextButton") {
      const text = String(it.text || "");
      const textColor = parseColor(it.textColor || "#e5e7eb");
      const fontSize = clamp(toNum(it.fontSize, 18), 8, 96);

      lines.push(`  node.Text = ${JSON.stringify(text)}`);
      lines.push(`  node.TextColor3 = ${textColor.color3}`);
      lines.push(`  node.TextTransparency = ${textColor.transparency.toFixed(3)}`);
      lines.push(`  node.TextSize = ${Math.round(fontSize)}`);
      lines.push(`  node.Font = Enum.Font.Gotham`);
      lines.push(`  node.TextWrapped = true`);
      lines.push(`  node.AutoButtonColor = false`);
      lines.push(``);
    }

    if (cls === "ImageLabel") {
      const img = String(it.imageId || "");
      const imgCol = parseColor("#ffffff");
      lines.push(`  node.ImageColor3 = ${imgCol.color3}`);
      lines.push(`  node.ImageTransparency = 0`);
      lines.push(`  node.ScaleType = Enum.ScaleType.Stretch`);
      if (img) {
        lines.push(`  node.Image = ${JSON.stringify(img)}`);
      } else {
        lines.push(`  -- node.Image = "rbxassetid://123456" -- set this in builder`);
      }
      lines.push(``);
    }

    if (cls === "TextButton") {
      lines.push(`  attachButtonFX(node)`);
      lines.push(``);

      if (type === "MonetizationButton") {
        const kind = String(it.monetizationKind || "DevProduct");
        const mid = String(it.monetizationId || "");

        lines.push(`  node.Activated:Connect(function()`);
        lines.push(`    local id = tonumber(${JSON.stringify(mid)})`);
        lines.push(`    if not id then`);
        lines.push(`      warn("MonetizationButton missing monetizationId")`);
        lines.push(`      return`);
        lines.push(`    end`);
        if (kind === "GamePass") {
          lines.push(`    MarketplaceService:PromptGamePassPurchase(player, id)`);
        } else if (kind === "CatalogItem") {
          lines.push(`    MarketplaceService:PromptPurchase(player, id)`);
        } else {
          lines.push(`    MarketplaceService:PromptProductPurchase(player, id)`);
        }
        lines.push(`  end)`);
        lines.push(``);
      }

      const rule = (it.interactions && it.interactions.OnClick) ? it.interactions.OnClick : it.onClick;
      if (rule && typeof rule === "object") {
        const safeRule = JSON.stringify(rule);
        lines.push(`  node.Activated:Connect(function()`);
        lines.push(`    applyRule(${safeRule})`);
        lines.push(`  end)`);
        lines.push(``);
      }
    }

    lines.push(`end`);
    lines.push(``);
  }

  lines.push(`-- Canvas reference: ${w}x${h}`);
  lines.push(``);

  // Build a manifest object with the canvas size and all exported items.
  const manifest = {
    canvasSize: { w, h },
    items: srcItems,
  };

  // Emit the manifest inside a long-string comment so the UI preview can extract it.
  lines.push(`--[==[UI_BUILDER_JSON`);
  lines.push(JSON.stringify(manifest, null, 2));
  lines.push(`]==]`);
  lines.push(``);

  return lines.join("\n");
}
